;Copyright Nomagno 2021, 2022

;Redistributions, modified or unmodified, in whole or in part, must retain
;applicable notices of copyright or other legal privilege, these conditions, and
;the following license terms and disclaimer.  Subject to these conditions, each
;holder of copyright or other legal privileges, author or assembler, and
;contributor of this work, henceforth "licensor", hereby grants to any person
;who obtains a copy of this work in any form:

;1. Permission to reproduce, modify, distribute, publish, sell, sublicense, use,
;and/or otherwise deal in the licensed material without restriction.

;2. A perpetual, worldwide, non-exclusive, royalty-free, gratis, irrevocable
;patent license to make, have made, provide, transfer, import, use, and/or
;otherwise deal in the licensed material without restriction, for any and all
;patents held by such licensor and necessarily infringed by the form of the work
;upon distribution of that licensor's contribution to the work under the terms
;of this license.

;NO WARRANTY OF ANY KIND IS IMPLIED BY, OR SHOULD BE INFERRED FROM, THIS LICENSE
;OR THE ACT OF DISTRIBUTION UNDER THE TERMS OF THIS LICENSE, INCLUDING BUT NOT
;LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
;AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS, ASSEMBLERS, OR HOLDERS OF
;COPYRIGHT OR OTHER LEGAL PRIVILEGE BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER
;LIABILITY, WHETHER IN ACTION OF CONTRACT, TORT, OR OTHERWISE ARISING FROM, OUT
;OF, OR IN CONNECTION WITH THE WORK OR THE USE OF OR OTHER DEALINGS IN THE
;WORK.




; Base assembly file. To use the definitions here, simply 
; copy it to your own. To preprocess your code 
; so it can be accepted by the assembler, run ./asmpp.sh myfile.hwasm
; Note: subroutine IDs 0x0 through 0xF are RESERVED by this document
; Note: the subroutines in this base document may use any of the shorthand addresses
; Note: the pseudo-instructions may use any of the first eight shorthand addresses (!A ?A !B ?B !C ?C !D ?D)

; Formally specified special registers:
; zero flag, carry flag, input, output,
; program counter low/high, error trigger
#d _ZF,FFFF
#d _CF,FFFE
#d _IN,FFFD
#d _OU,FFFC
#d _PCL,FFFB
#d _PCH,FFFA
#d _ERR,FFF0

; Implementation-defined special registers
#d _S1,FFF1
#d _S2,FFF2
#d _S3,FFF3
#d _S4,FFF4
#d _S5,FFF5
#d _S6,FFF6
#d _S7,FFF7
#d _S8,FFF8
#d _S9,FFF9

; Shorthand addresses (ABCD reserved for pseudo-instructions,
; don't write to these unless you know what you're doing).
; ! means high byte, ? low byte
#d !A,0
#d ?A,1
#d !B,2
#d ?B,3
#d !C,4
#d ?C,5
#d !D,6
#d ?D,7
#d !W,8
#d ?W,9
#d !X,A
#d ?X,B
#d !Y,C
#d ?Y,D
#d !Z,E
#d ?Z,F

; Maximum values
#d MAX8,FF
#d MAX16,FFFF

; Pseudo-instruction macros

; Start of loop
; save program counter low and high, add to it
; so the loop starts where it needs to, account for overflow
#d LOOP,set FFFB ?A __ set FFFA !A __ add ?A =4 __ add !A _CF
; Loop if _ZF is zero
#d ZWHILE,jcz &!A
; Loop if _ZF is nonzero
#d NWHILE,jcnz &!A
; Manual flow control, dangerous!
#d FOREVER,jmp &!A 


; STANDARD LIBRARY INTERFACES

; STACK DATA STRUCTURE:
; - It has a start address
; - Higher addresses are later in the stack
; - The first two addresses of the stack denote
; the current address the stack pointer is at:
; 0 3 12 53 6 FF -> Stack from addresses 0 to 5, with 
; stack pointer at address 3

; Stack operation subroutines:
; Push to stack - INTERFACE:
; &!W - Start address of push
; !X - Number of addresses to push
; &!Y - Stack start address
#d PUSH,=2
; Pop from stack - INTERFACE:
; !X - Number of addresses to pop
; &!Y - Stack start address
#d POP,=3

; Memory range operation subroutines:
; Set memory range to value - INTERFACE:
; !W - Value to set
; &!X - Range start
; &!Y - Range end
#d MEMSET,=0

; Copy memory range  - INTERFACE:
; (ranges must nor overlap)
; &!W - Orig range start
; &!X - Orig range end
; &!Y - Dest range start
; &!Z - Dest range end
#d MEMCPY,=1
