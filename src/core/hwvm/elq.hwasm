;Copyright Nomagno 2022
;
;Redistributions, modified or unmodified, in whole or in part, must retain
;applicable notices of copyright or other legal privilege, these conditions, and
;the following license terms and disclaimer.  Subject to these conditions, each
;holder of copyright or other legal privileges, author or assembler, and
;contributor of this work, henceforth "licensor", hereby grants to any person
;who obtains a copy of this work in any form:
;
;1. Permission to reproduce, modify, distribute, publish, sell, sublicense, use,
;and/or otherwise deal in the licensed material without restriction.
;
;2. A perpetual, worldwide, non-exclusive, royalty-free, gratis, irrevocable
;patent license to make, have made, provide, transfer, import, use, and/or
;otherwise deal in the licensed material without restriction, for any and all
;patents held by such licensor and necessarily infringed by the form of the work
;upon distribution of that licensor's contribution to the work under the terms
;of this license.
;
;NO WARRANTY OF ANY KIND IS IMPLIED BY, OR SHOULD BE INFERRED FROM, THIS LICENSE
;OR THE ACT OF DISTRIBUTION UNDER THE TERMS OF THIS LICENSE, INCLUDING BUT NOT
;LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
;AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS, ASSEMBLERS, OR HOLDERS OF
;COPYRIGHT OR OTHER LEGAL PRIVILEGE BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER
;LIABILITY, WHETHER IN ACTION OF CONTRACT, TORT, OR OTHERWISE ARISING FROM, OUT
;OF, OR IN CONNECTION WITH THE WORK OR THE USE OF OR OTHER DEALINGS IN THE
;WORK.

; Eloquent Runtime System library for Half-World assembly

#i base.hwasm

; A program in HWVM is *well-structured* when:
; - it does not contanin any 'jmp's to pointers
; - it does not read addresses past 7FFF, up until FFF9, but can read FFFA->FFFF, *except* FFFD
; - it does not write any addresses past 3FFFA, except FFFC, FFFE, FFFF
;
; A program in HWVM is *deterministic* when:
; - it only writes to R/W addresses
; - it only reads from mapped addresses
;
; The following minimal mapping for HWVM is *guaranteed*:
; 0000->FFFF: R/W, deterministic
; 4000->7FFF: R/O, deterministic
; FFF0      : UNMAPPED, deterministic
; FFFA      : R/O, chaotic
; FFFB      : R/O, chaotic
; FFFC      : R/W, deterministic
; FFFD      : R/O, nondeterministic
; FFFE      : R/W, chaotic
; FFFF      : R/W, chaotic
; --------------------------------------
; HWVM Runtime for HWElq:
; - Subroutine instructions unused
; MEMORY:
; 	- Section 1 (PUBLICPAGE) structure (32 bytes): 
; 		- Address zero (1 byte, base case for pointers) 
; 		- Public 'garbage' bytes (31 bytes)
; 	- Section 2 (VARHEAP) structure (32 bytes):
; 		- Lookup table for 'define' (16x ADDRESSES (2 bytes))
; 	- Section 3 (CALLSTACK) structure (512 bytes): 
; 		- 8x STACKFRAMEs
; 	- Section 4 (NODEHEAP) structure (444 bytes + 4 padding bytes):
; 		- 74x manually (de)allocated NODEs
;
; 	STRACKFRAME data structure (32 bytes):
; 		- RETURN ADDRESS (2 bytes)
; 		- 6x LOCAL VARIABLE ADDRESSES (2 bytes)
; 		- RETVAL VARIABLE ADDRESS (2 bytes)
; 		- PRIVATE DATA (16 bytes)
; 	NODE data structure (6 bytes):
; 		- ALLOC (1 byte)
; 		- TYPE (1 byte)
; 		- DATA (2 bytes)
; 		- NEXT (2 bytes)
; 	NODE internal structure per type:
; 		- NIL       (TYPE FIELD: 0) (DATA       FIELD      UNUSED)
; 		- Unsigned  (TYPE FIELD: 1) (DATA FIELD HIGH BYTE:  value)
; 		- Pair      (TYPE FIELD: 2) (DATA FIELD:     node address)
;		- Procedure (TYPE FIELD: 3) (DATA FIELD: procedure address) (NEXT FIELD: 0 or varX (NEXT FIELD: 0 or varY (NEXT FIELD: 0 or ...)))

; Save program counter, FOUR instructions:
#d SAVEPC,set FFFB ?W __ set FFFA !W __ add ?W =1 __ nop

; Stack data structure:
; Byte 0: high address of stack pointer
; Byte 1: low address of stack pointer

; Responsibilities for caller/callee of a manual subroutine:
; Caller:
;    - allocate stackframe (with PUSHFRAME)
;    - fill in !Z and ?Z with the start of the frame
;    - fill in return address in the frame with suitable PC number, within subroutine
;    - fill in copies of local variables (first the arguments in order, 
;           then the packaged vars in order, contiguously)
;    - jump to subroutine
; Callee:
;    - do computations
;    - clean up (don't leave any data but the retval variable allocated)
;    - fill in return retval variable address of previous stack frame
;        (node to be owned by caller)
;    - jump to return address
; Caller:
;    - destroy copies of local variables
;    - destroy stackframe (with POPFRAME)

; Regular subroutines, they won't be called recursively
#d PUSHFRAME,=10
#d POPFRAME,=11
