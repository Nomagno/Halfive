;Copyright Nomagno 2022
;
;Redistributions, modified or unmodified, in whole or in part, must retain
;applicable notices of copyright or other legal privilege, these conditions, and
;the following license terms and disclaimer.  Subject to these conditions, each
;holder of copyright or other legal privileges, author or assembler, and
;contributor of this work, henceforth "licensor", hereby grants to any person
;who obtains a copy of this work in any form:
;
;1. Permission to reproduce, modify, distribute, publish, sell, sublicense, use,
;and/or otherwise deal in the licensed material without restriction.
;
;2. A perpetual, worldwide, non-exclusive, royalty-free, gratis, irrevocable
;patent license to make, have made, provide, transfer, import, use, and/or
;otherwise deal in the licensed material without restriction, for any and all
;patents held by such licensor and necessarily infringed by the form of the work
;upon distribution of that licensor's contribution to the work under the terms
;of this license.
;
;NO WARRANTY OF ANY KIND IS IMPLIED BY, OR SHOULD BE INFERRED FROM, THIS LICENSE
;OR THE ACT OF DISTRIBUTION UNDER THE TERMS OF THIS LICENSE, INCLUDING BUT NOT
;LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
;AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS, ASSEMBLERS, OR HOLDERS OF
;COPYRIGHT OR OTHER LEGAL PRIVILEGE BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER
;LIABILITY, WHETHER IN ACTION OF CONTRACT, TORT, OR OTHERWISE ARISING FROM, OUT
;OF, OR IN CONNECTION WITH THE WORK OR THE USE OF OR OTHER DEALINGS IN THE
;WORK.

; Eloquent Runtime System library for Half-World assembly

#i base.hwasm

; A program in HWVM is *well-structured* when:
; - it does not contanin any 'jmp's to pointers
; - it does not read addresses past 7FFF, up until FFF9, but can read FFFA->FFFF, *except* FFFD
; - it does not write any addresses past 3FFFA, except FFFC, FFFE, FFFF
;
; A program in HWVM is *deterministic* when:
; - it only writes to R/W addresses
; - it only reads from mapped addresses
;
; The following minimal mapping for HWVM is *guaranteed*:
; 0000->FFFF: R/W, deterministic
; 4000->7FFF: R/O, deterministic
; FFF0      : UNMAPPED, deterministic
; FFFA      : R/O, chaotic
; FFFB      : R/O, chaotic
; FFFC      : R/W, deterministic
; FFFD      : R/O, nondeterministic
; FFFE      : R/W, chaotic
; FFFF      : R/W, chaotic
; --------------------------------------
; HWVM Runtime for HWElq:
; - Subroutine instructions unused
; MEMORY:
; 	- Section 1 (PUBLICPAGE) structure (32 bytes):
; 		- Address zero (base case for pointers)
; 		- Public 'garbage' bytes (31 bytes)
#d _E_S_PUBPAGE,0000
#d _E_S_H_PUBPAGE,00
#d _E_S_L_PUBPAGE,00

#d _E_F_PUBPAGE,001F
#d _E_S_H_PUBPAGE,00
#d _E_S_L_PUBPAGE,1F

; 	- Section 2 (VARHEAP) structure (256 bytes) (20->11F):
; 		- Lookup table for 'define' (128x ADDRESSES)
#d _E_S_VARHEAP,0020
#d _E_S_H_VARHEAP,00
#d _E_S_L_VARHEAP,20

#d _E_F_VARHEAP,011F
#d _E_S_H_VARHEAP,01
#d _E_S_L_VARHEAP,1F

; 	- Section 3 (NODEHEAP) structure (735 bytes + 1 padding byte) (120->0FFF):
; 		- 147x manually (de)allocated NODEs
#d _E_S_NODEHEAP,0120
#d _E_S_H_NODEHEAP,01
#d _E_S_L_NODEHEAP,20

#d _E_F_NODEHEAP,0FFF
#d _E_S_H_NODEHEAP,0F
#d _E_S_L_NODEHEAP,FF

; 	- Section 4 (CALLSTACK) structure (1026 bytes) (1000->2001): 
;		- 2 bytes for position of stack pointer
; 		- 16x STACKFRAMEs
#d _E_S_CALLSTACK,1000
#d _E_S_H_CALLSTACK,10
#d _E_S_L_CALLSTACK,00

#d _E_F_CALLSTACK,2001
#d _E_S_H_CALLSTACK,20
#d _E_S_L_CALLSTACK,01

; --------------------------------------
; 	STRACKFRAME data structure (32 bytes):
; 		- RETURN ADDRESS (2 bytes)
; 		- 6x LOCAL VARIABLE ADDRESSES (2 bytes)
; 		- RETVAL VARIABLE ADDRESS (2 bytes)
; 		- PRIVATE DATA (16 bytes)
; 	NODE data structure (5 bytes):
;		- META BYTE (A0LLLRRR)
;			A - allocated?
;			0 - padding
;			LLL - left type
;			RRR - right type
; 		- DATA LEFT (2 bytes)
; 		- DATA RIGHT (2 bytes)
; 	NODE internal structure per type:
; 		- EMPTY     (TYPE FIELD: 0) (DATA       FIELD      UNUSED)
; 		- NIL       (TYPE FIELD: 1) (DATA       FIELD      UNUSED)
; 		- Unsigned  (TYPE FIELD: 2) (DATA FIELD HIGH BYTE:  value)
; 		- Pair      (TYPE FIELD: 3) (DATA FIELD:     node address)
;		- Procedure (TYPE FIELD: 4) (DATA FIELD: pointer to a special CLOSURENODE)
;       - CLOSURENODE: 
;                                 (META BYTE: 0xC (11001010)), 
;                                 (DATA FIELD: address of procedure),
;                                 (RIGHT FIELD: proper NIL-terminated list)


; Save program counter, FOUR instructions:
#d SAVEPC,set FFFB ?W __ set FFFA !W __ add ?W =1 __ nop

; Stack data structure:
; Byte 0: high address of stack pointer
; Byte 1: low address of stack pointer

; Responsibilities for caller/callee of a manual subroutine:
; Caller:
;    - allocate stackframe (with PUSHFRAME)
;    - fill in !Z and ?Z with the start of the frame
;    - fill in return address in the frame with suitable PC number, within subroutine
;    - fill in copies of local variables (first the arguments in order, 
;           then the packaged vars in order, contiguously)
;    - jump to subroutine
; Callee:
;    - do computations
;    - clean up (don't leave any data but the retval variable allocated)
;    - fill in return retval variable address of previous stack frame
;        (node to be owned by caller)
;    - jump to return address
; Caller:
;    - destroy copies of local variables
;    - destroy stackframe (with POPFRAME)

; Regular subroutines, they won't be called recursively

; PUSH_FRAME, reads from !Y and ?Y the start address of the stack, from !X the frame size,
;     fills in !Z and ?Z with the start address of the pushed 32-byte frame
#d PUSH_FRAME,=10
func PUSH_FRAME
	add ?Y !X
	add !Y _CF
	set !Z !Y
	set ?Z ?Y
ret PUSH_FRAME

; POP_FRAME, reads from !Y and ?Y the start address of the stack, from !X the frame size, pops frame
;     fills in !Z and ?Z with the start address of the frame after popping
#d POP_FRAME,=11
func POP_FRAME
	sub ?Y !X
	sub !Y _CF
	set !Z !Y
	set ?Z ?Y
ret POP_FRAME

; ALLOC_NODE, fills in !Z and ?Z with the start address of the allocated node
#d ALLOC_NODE,=12
func ALLOC_NODE
	set ?B _E_S_L_NODEHEAP
	set !B _E_S_H_NODEHEAP
	; START OF LOOP
	set _ZF &!B ; Set zero flag to alloc byte
	INV_ZF ; Invert the zero flag
	  ;
	  ;
	  ;
	skpz =5 ; If the alloc byte is zero
		or &!B =80 ; Set alloc flag to true
		set ?Z ?B ; Set return register to node address
		set !Z !B ; Set return register to node address
		set _ZF =0
		skpz =3 ; Terminate
	add ?B =5
	add !B _CF ; Increase node start address by 5
	skmz =12 ; Loop
ret ALLOC_NODE

; DEALLOC_NODE, reads from !Z and ?Z the start address of the node of to deallocate
; Uses stack with frames of two bytes in size, where the type of
;    the nodes they point to is modified iteratively,
;    so as to turn a cons cell into an empty node that
;    can be deallocated, using a depth-first search algorithm
;    on the binary trees formed by the nodes
#d DEALLOC_NODE,=13
;;;func DEALLOC_NODE
;;;	set ?B ?Z
;;;	set !B !Z
;;;	set !C &!B ; Copy meta byte
;;;	set ?C &!B ; Copy meta byte
;;;	and !C =38 ; Preserve only left type
;;;	rot !C =B  ; Bitshift right 3 bits
;;;	and ?C =07 ; Preserve only right type
;;;	cmp !C =3
;;;	set !D _CF ; Check if left type is less than 3 (2, 1 or 0, atom types)
;;;	cmp ?C =3
;;;	set ?D _CF ; Check if right type is less than 3 (2, 1 or 0, atom types)
;;;	set !X !D  ; Store first comparison
;;;	cmp !X ?D  ; Compare both comparisons (Is the cell a pair of atoms or an atom?)
;;;	INV_ZF     ; Invert comparison
;;;	  ;
;;;	  ;
;;;	  ;
;;;	skpz XX ; If both fields are atomic
;;;		set &!B =0 ; Clear meta byte
;;;		; IF STACK IS EMPTY, TERMINATE
;;;		; ELSE, CLEAR STACK, POP FROM STACK, MODIFY PREVIOUS FRAME, AND LOOP
;;; ........................................................... (UNFINISHED/PROTOTYPE)
;;;ret DEALLOC_NODE
