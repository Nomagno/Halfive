;Copyright Nomagno 2021, 2022, 2023
;
;Redistributions, modified or unmodified, in whole or in part, must retain
;applicable notices of copyright or other legal privilege, these conditions, and
;the following license terms and disclaimer.  Subject to these conditions, each
;holder of copyright or other legal privileges, author or assembler, and
;contributor of this work, henceforth "licensor", hereby grants to any person
;who obtains a copy of this work in any form:
;
;1. Permission to reproduce, modify, distribute, publish, sell, sublicense, use,
;and/or otherwise deal in the licensed material without restriction.
;
;2. A perpetual, worldwide, non-exclusive, royalty-free, gratis, irrevocable
;patent license to make, have made, provide, transfer, import, use, and/or
;otherwise deal in the licensed material without restriction, for any and all
;patents held by such licensor and necessarily infringed by the form of the work
;upon distribution of that licensor's contribution to the work under the terms
;of this license.
;
;NO WARRANTY OF ANY KIND IS IMPLIED BY, OR SHOULD BE INFERRED FROM, THIS LICENSE
;OR THE ACT OF DISTRIBUTION UNDER THE TERMS OF THIS LICENSE, INCLUDING BUT NOT
;LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
;AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS, ASSEMBLERS, OR HOLDERS OF
;COPYRIGHT OR OTHER LEGAL PRIVILEGE BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER
;LIABILITY, WHETHER IN ACTION OF CONTRACT, TORT, OR OTHERWISE ARISING FROM, OUT
;OF, OR IN CONNECTION WITH THE WORK OR THE USE OF OR OTHER DEALINGS IN THE
;WORK.


; To be able to use the definitions here,
; include at the start of your file:
; #i /path/to/base.h5asm

; INCLUDE
; #i /path/to/file.h5asm
; file.h5asm substituted in place of statement and preprocessed normally

; MACRO
; #d macro,meaning
; Every instance of macro is replaced with meaning, starting expansion with the ones defined later

; LABEL
; >LABELNAME>
; Must appear at the beggining of a line containing a
; regular instruction after the preprocessing stage.
; All references in the code to <LABELNAME< get replaced
; with the difference of the instruction index to instruction
; index >LABELNAME> appeared in. Used for absolute jumping
; with skpz and skmz

; To preprocess your code so it can
; be accepted by the assembler, run:
; sh asmpp.sh /path/to/yourcode.h5asm > preprocessed_file


; Base library for Halfive assembly
; Contains:
;   Special register mnemonic macros
;   Two utility pseudo-instructions
;   Shorthand symbols for 16 first addresses

; Specification-defined registers:

; Zero flag
#d _ZF,FFFF
; Carry flag
#d _CF,FFFE
; Input register
#d _IN,FFFD
; Output register
#d _OU,FFFC
; Program counter low and high
#d _PC,FFFB
; Purposefully unmapped memory
#d _ERR,FFF0

;Shorthand addresses:
#d !A,0
#d ?A,1
#d !B,2
#d ?B,3
#d !C,4
#d ?C,5
#d !D,6
#d ?D,7
#d !W,8
#d ?W,9
#d !X,A
#d ?X,B
#d !Y,C
#d ?Y,D
#d !Z,E
#d ?Z,F


; Pseudo-instructions:

; Normalize zero flag, TWO instructions:
; if it is nonzero set it to one
#d NRM_ZF,skpz =1 __ set _ZF =1

; Invert zero flag, FOUR instructions:
; if it is nonzero set it to zero,
; if it is zero set it to one
#d INV_ZF,skpz =2 __ set _ZF =0 __ skpz =1 __ set _ZF =1

; Constant for info on callstack
#d @,=C00F


; Subroutine _PRINT, ID =0
; Takes pointer to start of memory to print at pointer 0
; And number of times to print at address 1
#d _PRINT,=0
func _PRINT @ ; Start of subroutine print
	>PRINT_LOOP> set _OU *0 ; Print out value at pointer 0
		add 0 =1 ; Increment pointer
		sub 1 =1 ; Decrement loop counter
		INV_ZF ; Invert zero flag
	skmz <PRINT_LOOP< ; Jump back to start of loop if addr. 1 != 0
ret _PRINT @ ; End of subroutine print

; EXAMPLE PROGRAM, PRINT 'DEADBEEF'
	;set 4 =D
	;set 5 =E
	;set 6 =A
	;set 7 =D
	;set 8 =B
	;set 9 =E
	;set A =E
	;set B =F ; DEADBEEF
	;set 0 =0004 ; Set start address of string to print
	;set 1 =8 ; Size of print range
	;call _PRINT @ ; Call to subroutine print
	;halt ; Halt
; END OF EXAMPLE PROGRAM

; Subroutine _MULT, ID =1
; Takes first operand at address 0
; And second operand at address 1
; Then deposits result of multiplication at address 2
#d _MULT,=1
func _MULT @ ; Start of subroutine mult
	>MULT_LOOP> add 2 0 ; Add first operand
		sub 1 =1 ; Decrement loop counter
		INV_ZF ; Invert zero flag
	skmz <MULT_LOOP< ; Jump back to start of loop if addr. 1 != 0
ret _MULT @ ; End of subroutine mult

; Subroutine _MULT_REC, ID =2
; Takes first operand at address 0
; And second operand at address 1
; Then deposits result of multiplication at address 2
#d _MULT_REC,=1
func _MULT_REC @ ; Start of recursive subroutine mult
	add 2 0 ; Add first operant
	sub 1 =1 ; Decrement loop counter
	skpz =1 ; If zero, skip recursive call
	call _MULT_REC @ ; Loop
ret _MULT_REC @ ; End of recursive subroutine mult

; EXAMPLE PROGRAM, MULTIPLY 0x9 and 0x2
;	set 0 =9 ; Set first operand
;	set 1 =5 ; Set second operand
;	call _MULT @ ; Call to subroutine mult
;	set _OU 2 ; Expected result is 0x2D
;
;	set 2 =0 ; Reset output address
;	set 0 =9 ; Set first operand
;	set 1 =5 ; Set second operand
;	call _MULT_RECURSIVE @ ; Call to recursive subroutine mult
;	set _OU 2 ; Expected result is 0x2D
;
;	halt ; Halt
; END OF EXAMPLE PROGRAM
