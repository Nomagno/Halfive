<head>
<style type="text/css">
body{
line-height:1.6;
font-size:18px;
color:#444;
padding:0
10px}
h1,h2,h3{
line-height:1.2
}
</style>
	<title>Half-World Design N otes</title>
	<meta name="description" content="The Universal Racing Game">
</head>

<h1>Half-World Design notes</h1>
<h4>SPDX identifier: COIL-1.0</h4>
<h4>Copyright Nomagno 2022</h4>
<hr />
<h3>Missing suitable (re)implementations</h3>
<p>The hwrpg.h header, for simulating turn-based combat, is awaiting an implementation. It is meant to be an easter egg (SIMPLE)</p>
<p>The hwdoc.h header, for processing the HWDOC format, is awaiting a reimplementation to make its internal data structures child-linked rather than parent-linked (SIMPLE)</p>
<p>The Half-World Track format needs a minor redesign to allow a track to be defined by two bezier curve loops, rather than a single loop and a width parameter. The rationale is it is needed to achieve complex and rich racing tracks (SIMPLE)</p>
<p>The hwt.h and hwnet.h headers, to tokenize Half-World Track and Half-World Network .hwdoc files, respectively, are awaiting an implementation (TEDIOUS).</p>
<p>The halfive.h header, for simulating physics, is awaiting an implementation that uses fixed-timestep semi-explicit Euler integration to remain framerate-independent, as well as a redesign that includes the possibility of custom objects that aren&#x2019;t just cars, and of well-defined actions that may be mapped to real code or to a HWVM instance. (HARD)</p>
<h3>Missing suitable interfaces and implementations</h3>
<p>The rat.h header needs expansion with a more comprehensive math library that has auxiliary functions and data structures such as trigonometry stuff, quadratic bezier curve calculations, composite-type (e.g.&#xA0;8-bit and 16-bit composite integers for x and y) vector operations, etcetera: hwmath.h (TEDIOUS)</p>
<p>The hwvi.h header needs a big library with auxiliary software rendering functions such as blitting, bitmap text rendering, arbirary shapes, line rendering, quadratic bezier curve rendering, etcetera: hwrender.h (TEDIOUS)</p>
<p>The Half-World Pixel format needs a library utilities for converting to/from at least BMP, JPG and SVG images: hwpix.h (HARD)</p>
<p>A new comprehensive, higher-level implementation for user interface, track rendering, network code handling, balancing, content, etcetera, that exists on top of all other low-level modules, is needed: halfworld_engine.h (HARD)</p>
<hr />
<h3>General design notes about the game</h3>
<h4>Half-World is meant to be a racing game engine as well as a game that isn&#x2019;t inherently constrained to any type of gameplay, however not making a flagship physics engine implementation and base game to go with it would be simply disingenous.</h4>
<h4>A few overarching notes about code architecturing, game design, atmosphere and car handling are clear:</h4>
<ul>
<li><strong>The game takes place in a modern human society</strong>. It does not, by default, feature death machines, a complete in-universe disregard for safety, or any other messed up stuff like that.</li>
<li><strong>The cars are not magical</strong>. Cars are propulsed by two long electromagnets on their bottom, and the handling reflects it. They levitate, run dangerously close to the floor on ocassion, and without electronic assistance handling is extremely unstable at low speeds.</li>
<li><strong>Tracks are distinct</strong>. Tracks are made out of superconductors for the highest-tier elite racing series, and simple metals for the &#x2018;karting&#x2019; equivalent everyday ones.</li>
<li><strong>Computers are vital to the game</strong>. The entire point of HWVM (Half-World Virtual machine) is to provide a reasonably human-friendly, easily-abstractable but purposefully inefficient microcontroller framework. Car sensors, displays, and everything else is memory mapped. Most of the cars (specially the elite-tier ones) are incredibly inconvenient to handle without a properly configured computer to assist you, to change the handling, to stabilize them, to show information about the rivals etcetera.</li>
<li><strong>There is no escaping strategy</strong>. The cars are electrical, have a battery level that needs to be managed, the magnets wear down due to accidental or purposeful introduction of thermal elements and dust to the tracks. Just as in real car racing, you might have car types where the time spent in pits is negligible, and others where the strategic importance of a well-timed undercut is of note.</li>
<li><strong>Competition is important</strong>. While some series and rulesets and specific moments in specific races might have luck elements, the reality is that you mostly will not get automatically boosted to keep up with your rivals</li>
<li><strong>This project is useless if it can&#x2019;t be forked</strong>. The entire point of this game is to have an engine where you know where to change things, where it&#x2019;s clear how to do something, no matter how complex. The Half-World project, the Universal Racing Game, has failed if it needs to be wholly redesigned to adapt to a forker&#x2019;s needs.</li>
<li><strong>However, reimplementation is vital</strong>. It is humbly acknowledged that this game is not well optimized, that it relies on staying small to run fast, and that its architecturing philosophy is not pragmatic but rather in search of reaching distilled perfection. All symbols, all functions, all features, all interfaces, everything, should be easy to rewrite to run faster, to redesign to suit a specific system, to scale up, down, right, or left.</li>
<li><strong>Double buffer things</strong>. While this obviously introduces a tiny bit of overhead and increases the memory footprint, at least adding a compile-time option to make the game state double buffered on systems where multithreading might be supported in the future would be nice.</li>
</ul>
