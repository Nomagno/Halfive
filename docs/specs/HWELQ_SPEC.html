<head>
<style type="text/css">
body{
line-height:1.6;
font-size:18px;
color:#444;
padding:0
10px}
h1,h2,h3{
line-height:1.2
}
</style>
	<title>Half-World Eloquent Lisp</title>
	<meta name="description" content="The Universal Racing Game">
</head>

<h1>Half-World Eloquent Lisp</h1>
<h4>SPDX identifier: COIL-1.0</h4>
<h4>Copyright Nomagno 2022</h4>
<p>It is recommended to use the &#x201C;.hwelq&#x201D; extension for HW-Eloquent code files (where applicable). HW-Eloquent is identified by the MIME type <code>text/hwelq</code></p>
<h3>HW-Eloquent is a minimalistic Lisp dialect to abstract over HWVM programs</h3>
<h4>SYNTAX:</h4>
<ul>
<li>If statement:
<ul>
<li><code>(if bool</code> -&gt; If <code>bool</code> evaluates to an atom that is not 0
<ul>
<li><code>ontrue</code> -&gt; Evaluate this</li>
<li><code>onfalse)</code> -&gt; Otherwise evaluate this</li>
</ul></li>
</ul></li>
<li>Begin Statement: <code>(begin expr1 expr2 ... exprN)</code>
<ul>
<li>Evaluates expressions in order. The <code>begin</code> statement itself evaluates to whatever the last expression evaluates to</li>
</ul></li>
<li>Lambda statement:
<ul>
<li><code>(lambda args body)</code></li>
<li><code>args</code> -&gt; List of variables provided as input, e.g.&#xA0;<code>(a b c)</code></li>
<li><code>body</code> -&gt; Code to evaluate when calling the procedure, can contain any syntax, input variables, or global variables</li>
<li>Evaluates to an unnamed procedure that takes the number of arguments in the <code>args</code> list, and evaluates <code>body</code>, substituting them inside as appropiate</li>
</ul></li>
<li>Procedure call: <code>(procedure arg1 arg2 ...)</code>
<ul>
<li>Call procedure with arguments. The arguments are evaluated in left-to-right order before passing them to the procedure.</li>
</ul></li>
<li>Define variable: <code>(define variable value)</code>
<ul>
<li>Make variable name mean a specific value globally.</li>
<li>EXAMPLE: <code>(define myfunc (lambda x (fn x)))</code>
<ul>
<li>Defines <code>myfunc</code> to mean the evaluation of the <code>lambda</code> statement, that is, a procedure that is passed an argument, and evaluates to <code>fn</code> applied to that argument. Can be called like <code>(myfunc 42)</code>.</li>
</ul></li>
</ul></li>
</ul>
<h3>CORE PROCEDURES:</h3>
<ul>
<li>PROCEDURE: (CONStruct dotted pair): <code>(cons A B)</code> -&gt; <code>(A . B)</code>
<ul>
<li>Result is known as a cons cell.</li>
</ul></li>
<li>PROCEDURE: <code>(car a)</code>
<ul>
<li>Left element of cons cell <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(cdr a)</code>
<ul>
<li>Right element of cons cell <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(nil? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is <code>%</code>. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(atom? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is an atom. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(procedure? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is a procedure, otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(eq? a b)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> and <code>b</code> are identical, otherwise it evaluates to 0.</li>
</ul></li>
</ul>
<h3>OPERATION PROCEDURES:</h3>
<ul>
<li>RULES:
<ul>
<li>The first six apply the operation, and evaluate to an unsigned scalar cons cell of the form <code>(A . (B . C))</code>, where <code>A</code> is the result, <code>B</code> is only zero if the result was zero, and <code>C</code> is only zero wether there was underflow/overflow (only for <code>add</code>, <code>substract</code>, otherwise its value is undefined).</li>
<li><code>halt</code> evaluates to 0, as it is only useful for its side effects.</li>
</ul></li>
<li>PROCEDURE: (bitwise add): <code>(add x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise substract): <code>(sub x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise and): <code>(and x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise or): <code>(or x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise xor): <code>(xor x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise rot): <code>(rot x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (address set): <code>(set addrpair y)</code>
<ul>
<li>Where <code>addrpair</code> is a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to set, and <code>y</code> either evaluates to an unsigned scalar, or is a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to read. Evaluates to the value written to <code>addrpair</code>.</li>
</ul></li>
<li>PROCEDURE 17: <code>(halt)</code>
<ul>
<li>Terminates the program.</li>
</ul></li>
</ul>
<h3>SPECIAL RULES</h3>
<ul>
<li>N -&gt; Evaluates to N, where N is an 8-bit hexadecimal unsigned scalar</li>
<li>A list is either <code>%</code> or a cons cell where the right hand side is a list. Hence, <code>(a . b)</code>, <code>a</code>, <code>(a . (b . c) . %)</code> are not lists, but <code>(a . ((b . %) . %))</code>, <code>(a . %)</code> are lists.</li>
<li><code>(a b c)</code> notation stands for the list <code>(a . (b . (c . %)))</code>. Hence, <code>(procedure a b c)</code> stands for <code>(procedure . (a . (b . (c . %))))</code>. <code>((a b) c)</code> stands for <code>((a . (b . %)) . (c . %))</code>.</li>
<li>In Eloquent, every piece of data is either a cons cell or an atom. The only three possible types for atoms are unsigned scalar, procedure, or <code>%</code>. An atom may be checked for with the procedure <code>atom?</code>, <code>%</code> with the procedure <code>nil?</code>, procedure type with <code>procedure?</code>, and equality of two pieces of data with <code>eq?</code>. Giving atoms as arguments to <code>car</code> or to <code>cdr</code> is an ERROR.</li>
<li>Variables, declared using <code>define</code> or as <code>lambda</code> arguments, are replaced with their associated value. In the case of lambdas, their arguments are replaced with the evaluation of the provided expression in the procedure call. For example, <code>(lambda (myvar) (nand myvar 1))</code> would have <code>myvar</code> in the body replaced with the first argument it is passed, so <code>((lambda (myvar) (nand myvar 1)) 2)</code> would have the body evaluate to <code>(nand 2 1)</code>, which evaluates to the (hexadecimal base) scalar FC.</li>
<li>Variable names may contain any of <code>abcdefghijklmnopqrstuvwxyz?</code></li>
<li>Unsigned scalars may contain any of <code>0123456789ABCDEF</code></li>
<li>To <code>set</code> addresses lower than <code>(01 . 00)</code> is an ERROR. These lower addresses are reserved for special purposes.</li>
<li>To <code>set</code> an address to itself is considered only a read, and it is hence allowed even if the address is read-only.</li>
<li>Take into account HWVM allows addresses to be READ-ONLY or UNMAPPED. Writing to the former is an ERROR, doing anything with the latter is an ERROR.</li>
</ul>
