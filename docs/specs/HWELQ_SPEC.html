<head>
<style type="text/css">
body{
line-height:1.6;
font-size:18px;
color:#444;
padding:0
10px}
h1,h2,h3{
line-height:1.2
}
</style>
	<title>Half-World Eloquent Scheme</title>
	<meta name="description" content="The Universal Racing Game">
</head>

<h1>Half-World Eloquent Scheme</h1>
<h4>SPDX identifier: COIL-1.0</h4>
<h4>Copyright Nomagno 2022</h4>
<p>It is recommended to use the &#x201C;.hwelq&#x201D; extension for HW-Eloquent code files (where applicable). HW-Eloquent is identified by the MIME type <code>text/hwelq</code></p>
<h3>HW-Eloquent is a minimalistic Scheme Lisp dialect to abstract over HWVM programs</h3>
<h4>SYNTAX:</h4>
<ul>
<li>N -&gt; Evaluates to N, where N is an 8-bit hexadecimal unsigned scalar</li>
<li><code>'(expression)</code> -&gt; Return expression without evaluating, equivalent to <code>(quote (expression))</code>:
<ul>
<li>EXAMPLE 1: <code>((lambda (X) (car (x))) '(cons 1 2))</code> -&gt; <code>(car '(cons . (1 . 2)))</code> -&gt; <code>'cons</code></li>
<li>EXAMPLE 2: <code>((lambda (X) (car (x))) (cons 1 2))</code> -&gt; <code>(car (1 . 2))</code> -&gt; <code>1</code></li>
<li>SPECIAL CASE: <code>'()</code> -&gt; Special value pronounced NIL</li>
</ul></li>
<li>If statement:
<ul>
<li><code>(if (bool)</code> -&gt; If this evaluates to an atom that is not 0</li>
<li><code>(ontrue)</code> -&gt; Evaluate this</li>
<li><code>(onfalse))</code> -&gt; Otherwise evaluate this</li>
</ul></li>
<li><code>(procedure arg1 arg2...)</code> -&gt; Call procedure with arguments. <code>procedure</code> must</li>
<li><code>(begin (expr1) (expr2) (expr3) ... (exprN))</code> -&gt; Evaluates expressions in order. The <code>begin</code> statement itself evaluates to whatever the last expression evaluates to</li>
</ul>
<h3>CORE PROCEDURES:</h3>
<ul>
<li>PROCEDURE 1 (CONStruct dotted pair): <code>(cons A B)</code> -&gt; <code>(A . B)</code></li>
<li>PROCEDURE 2: <code>(car a)</code> -&gt; Left element of dotted pair <code>a</code></li>
<li>PROCEDURE 3: <code>(cdr a)</code> -&gt; Right element of dotted pair <code>a</code></li>
<li>PROCEDURE 4: (Create an unnamed procedure):
<ul>
<li><code>(lambda (args) (body))</code></li>
<li><code>args</code> -&gt; List of variables provided as input, e.g.&#xA0;<code>(a b c)</code></li>
<li><code>body</code> -&gt; Code to evaluate, can contain any syntax</li>
</ul></li>
<li>PROCEDURE 5: <code>(bind variable (args) (body))</code> -&gt; Make variable name mean a specific lambda, can not be redefined:
<ul>
<li>EXAMPLE: <code>(bind myfunc (x) (fn x))</code> -&gt; Creates procedure that is passed an argument, and evaluates to <code>fn</code> applied to that argument. can be called like <code>(myfunc 42)</code>.</li>
</ul></li>
<li>PROCEDURE 6: <code>(nil? a)</code> -&gt; Evaluates to 1 if <code>a</code> is <code>'()</code>, pronounced NIL. Otherwise it evaluates to 0.</li>
<li>PROCEDURE 7: <code>(atom? a)</code> -&gt; Evaluates to 1 if <code>a</code> is an atom. Otherwise it evaluates to 0.</li>
<li>PROCEDURE 8: <code>(procedure? a)</code> -&gt; Evaluates to 1 if <code>a</code> is a core procedure, otherwise it evaluates to 0.</li>
<li>PROCEDURE 9: <code>(eq? a b)</code> -&gt; Evaluates to 1 if <code>a</code> and <code>b</code> are identical, otherwise it evaluates to 0.</li>
</ul>
<h3>OPERATION PROCEDURES:</h3>
<ul>
<li>RULES:
<ul>
<li>All apply, accounting for the fact they do not deal with pointers, the instruction opcode of the same name in HWVM assembly, with the exact same behaviour.</li>
<li>The first six apply the operation, and evaluate to an unsigned scalar dotted pair of the form <code>(A . (B . C))</code>, where <code>A</code> is the result, <code>B</code> is only zero if the result was zero, and <code>C</code> is only zero wether there was underflow/overflow (only for <code>add</code>, <code>substract</code>, otherwise its value is undefined).</li>
<li><code>halt</code> evaluates to 0, as it is only useful for its side effects.</li>
</ul></li>
<li>PROCEDURE 10: (bitwise add): <code>(add x y)</code> -&gt; Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 11: (bitwise substract): <code>(sub x y)</code> -&gt; where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 12: (bitwise and): <code>(and x y)</code> -&gt; Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 13: (bitwise or): <code>(or x y)</code> -&gt; Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 14: (bitwise xor): <code>(xor x y)</code> -&gt; Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 15: (bitwise rot): <code>(rot x y)</code> -&gt; Where <code>x</code> and <code>y</code> evaluate to unsigned scalars.</li>
<li>PROCEDURE 16: (address set): <code>(set addrpair y)</code> -&gt; Where <code>addrpair</code> is a dotted pair of the form <code>(high . low)</code>, for the high and low byte of the address to set, and <code>y</code> either evaluates to an unsigned scalar, or is a dotted pair of the form <code>(high . low)</code>, for the high and low byte of the address to read. Evaluates to the value written to <code>addrpair</code>.</li>
<li>PROCEDURE 17: <code>(halt)</code> -&gt; Terminates the program.</li>
</ul>
<h3>SPECIAL RULES</h3>
<ul>
<li><code>'()</code>, pronounced NIL, is a special value that is treated as 0 when given as argument to the operation procedures.</li>
<li>Lists are dotted pairs where both sides of every pair are also a pair. Pairs are terminated by <code>'()</code>. Hence, <code>(a . b)</code>, <code>a</code>, <code>(a . (b . c) . ())</code> are not lists, but <code>(a . (b . ()) . ())</code>, <code>(a . ())</code> are lists.</li>
<li><code>(a b c)</code> notation stands for the list <code>(a . (b . (c . ())))</code>. Hence, <code>(procedure a b c)</code> stands for <code>(procedure . (a . (b . (c . ()))))</code>. <code>((a b) c)</code> stands for <code>((a . (b . ())) . (c . ()))</code>.</li>
<li>In Eloquent, every piece of data is either a dotted pair or an atom. The only three possible types for atoms are unsigned scalar, core procedure, or &#x2019;(). An atom may be checked for with the procedure <code>atom?</code>, nil type with the procedure <code>nil?</code>, core procedure type with <code>procedure?</code>, and equality of two pieces of data with <code>eq?</code>. Giving atoms as arguments to <code>car</code> or to <code>cdr</code> is an ERROR.</li>
<li>Variables, declared using bind or as lambda arguments, are replaced with their associated value. Variables may not appear in quoted expressions, since they don&#x2019;t mean anything there. In the case of lambdas, their arguments are replaced with the evaluation of the provided expression in the procedure call. For example, <code>(lambda (myvar) (nand myvar 1))</code> would have <code>myvar</code> in the body replaced with the first argument it is passed, so <code>((lambda (myvar) (nand myvar 1)) 2)</code> would have the body evaluate to <code>(nand 2 1)</code>, which evaluates to the (hexadecimal base) scalar FC.</li>
<li>Variable names may contain any of <code>abcdefghijklmnopqrstuvwxyz?</code></li>
<li>Unsigned scalars may contain any of <code>0123456789ABCDEF</code></li>
<li>To <code>set</code> addresses lower than <code>(01 . 00)</code> is an ERROR. These lower addresses are reserved for special purposes.</li>
<li>To <code>set</code> an address to itself is considered only a read, and it is hence allowed even if the address is read-only.</li>
<li>Take into account HWVM allows addresses to be READ-ONLY or UNMAPPED. Writing to the former is an ERROR, doing anything with the latter is an ERROR.</li>
</ul>
