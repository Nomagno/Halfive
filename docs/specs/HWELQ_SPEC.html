<head>
<style type="text/css">
body{
line-height:1.6;
font-size:18px;
color:#444;
padding:0
10px}
h1,h2,h3{
line-height:1.2
}
</style>
	<title>Half-World Eloquent Lisp</title>
	<meta name="description" content="The Universal Racing Game">
</head>

<h1>Half-World Eloquent Lisp</h1>
<h4>SPDX identifier: COIL-1.0</h4>
<h4>Copyright Nomagno 2022</h4>
<p>It is recommended to use the &#x201C;.hwelq&#x201D; extension for HW-Eloquent code files (where applicable). HW-Eloquent is identified by the MIME type <code>text/hwelq</code></p>
<h3>HW-Eloquent is a minimalistic Lisp dialect to abstract over HWVM programs</h3>
<h4>SYNTAX:</h4>
<ul>
<li>If statement:
<ul>
<li><code>(if bool</code> -&gt; If <code>bool</code> evaluates to an unsigned scalar that is not 0
<ul>
<li><code>ontrue</code> -&gt; Evaluate this</li>
<li><code>onfalse)</code> -&gt; Otherwise evaluate this</li>
</ul></li>
</ul></li>
<li>Begin Statement: <code>(begin expr1 expr2 ... exprN)</code>
<ul>
<li>Evaluates expressions in order. The <code>begin</code> statement itself evaluates to whatever the last expression evaluates to</li>
</ul></li>
<li>Lambda statement:
<ul>
<li><code>(lambda args body)</code></li>
<li><code>args</code> -&gt; List of variables provided as input, e.g.&#xA0;literally <code>(a b c)</code>, or if a single variable, <code>a</code>, or if no variables, <code>%</code></li>
<li><code>body</code> -&gt; Code to evaluate when calling the procedure, can contain any syntax, input variables, or global variables</li>
<li>Evaluates to an unnamed procedure that takes the number of arguments in the <code>args</code> list, and evaluates <code>body</code>, substituting them inside as appropiate</li>
<li>The variable called <code>self</code> represents the procedure itself, so it may be called to perform recursive calls, and it will run separately and perform independent variable substitution.</li>
</ul></li>
<li>Procedure call: <code>(procedure arg1 arg2 ...)</code>
<ul>
<li>Call procedure with arguments. The arguments are evaluated in left-to-right order before passing them to the procedure.</li>
</ul></li>
<li>Define variable: <code>(define variable value)</code>
<ul>
<li>Make variable name mean a specific value globally.</li>
<li>EXAMPLE: <code>(define myfunc (lambda x (if (eq? x 0) (0) (self (sub x 1)) )))</code>
<ul>
<li>Defines <code>myfunc</code> to mean the calling of <code>myfunc</code> as many times as the value of the unsigned scalar <code>x</code>, and it evaluates deterministically to the unsigned scalar <code>0</code>.</li>
</ul></li>
</ul></li>
</ul>
<h3>CORE PROCEDURES:</h3>
<ul>
<li>PROCEDURE: (CONStruct dotted pair): <code>(cons A B)</code> -&gt; <code>(A . B)</code>
<ul>
<li>Result is known as a cons cell.</li>
</ul></li>
<li>PROCEDURE: <code>(car a)</code>
<ul>
<li>Where <code>a</code> is a cons cell, evaluates to the left element of <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(cdr a)</code>
<ul>
<li>Where <code>a</code> is a cons cell, evaluates to the right element of <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(nil? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is <code>%</code>. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(atom? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is an atom. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(procedure? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is a procedure, otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(eq? a b)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> and <code>b</code> are both atoms, and both are the exact same atom. Otherwise it evaluates to 0.</li>
</ul></li>
</ul>
<h3>OPERATION PROCEDURES:</h3>
<ul>
<li>RULES:
<ul>
<li>The first six apply the operation, and evaluate to an unsigned scalar cons cell of the form <code>(A . (B . C))</code>, <code>A</code> is the result, <code>B</code> is only 0 if the result was zero, and <code>C</code> is only 1 when there was underflow/overflow (for <code>add</code> or <code>substract</code>, otherwise the value of <code>C</code> is irrelevant).</li>
<li><code>halt</code> evaluates to <code>%</code>, as it is only useful for its side effects.</li>
</ul></li>
<li>PROCEDURE: (bitwise add): <code>(add x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise substract): <code>(sub x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise and): <code>(and x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise or): <code>(or x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise xor): <code>(xor x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise rot): <code>(rot x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (address set): <code>(set addrpair y)</code>
<ul>
<li>Where <code>addrpair</code> is a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to set.</li>
<li>Where <code>y</code> is either an unsigned scalar, or a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to read. Evaluates to the value written to <code>addrpair</code>.</li>
</ul></li>
<li>PROCEDURE 17: <code>(halt)</code>
<ul>
<li>Terminates the program.</li>
</ul></li>
</ul>
<h3>CLARIFICATIONS</h3>
<ul>
<li>A list is either <code>%</code> or a cons cell where the right hand side is a list. Hence, <code>(a . b)</code>, <code>a</code>, <code>(a . (b . c) . %)</code> are not lists, but <code>(a . ((b . %) . %))</code>, <code>(a . %)</code> are lists.</li>
<li><code>(a b c)</code> notation stands for the list <code>(a . (b . (c . %)))</code>. Hence, <code>(procedure a b c)</code> stands for <code>(procedure . (a . (b . (c . %))))</code>. <code>((a b) c)</code> stands for <code>((a . (b . %)) . (c . %))</code>.</li>
<li>In Eloquent, every piece of data is either a cons cell or an atom. The only three possible types for atoms are unsigned scalar, procedure, or <code>%</code>.</li>
<li>An atom may be checked for with the procedure <code>atom?</code>, <code>%</code> with the procedure <code>nil?</code>, procedure type with <code>procedure?</code>, and equality of two atoms with <code>eq?</code>.</li>
<li>In the above text of the specification, whenever <code>where X is Y</code> appears, it is to be interpreted as a statement that <code>X</code> MUST be of type <code>Y</code>, and if it is not, an ERROR occurs.</li>
<li>Variables, declared using <code>define</code> or as <code>lambda</code> arguments, are replaced with their associated value. In the case of lambdas, their arguments are replaced with the evaluation of the provided expression in the procedure call. For example, <code>(lambda (myvar) (nand myvar 1))</code> would have <code>myvar</code> in the body replaced with the first argument it is passed, so <code>((lambda (myvar) (nand myvar 1)) 2)</code> would execute code equivalent to <code>(nand 2 1)</code>, which evaluates to the (hexadecimal base) scalar FC.</li>
<li>Variable names may contain any of <code>abcdefghijklmnopqrstuvwxyz?</code></li>
<li>Unsigned scalars may contain any of <code>0123456789ABCDEF</code></li>
<li>To <code>set</code> addresses lower than <code>(01 . 00)</code> is an ERROR. These lower addresses are reserved for special purposes.</li>
<li>To <code>set</code> an address to itself is considered only a read, and it is hence allowed even if the address is read-only.</li>
<li>Take into account HWVM allows addresses to be READ-ONLY or UNMAPPED. Writing to the former is an ERROR, doing anything with the latter is an ERROR.</li>
<li>No statement in this specification applies as soon as an ERROR has occurred. The program may continue functioning after handling the ERROR gracefully, it may stop functioning, or it may continue functioning in a noncompliant state.</li>
</ul>
