<h1>Half-World Eloquent Lisp</h1>
<h4>SPDX identifier: COIL-1.0</h4>
<h4>Copyright Nomagno 2022</h4>
<p>It is recommended to use the &#x201C;.hwelq&#x201D; extension for HW-Eloquent code files (where applicable). HW-Eloquent is identified by the MIME type <code>text/hwelq</code></p>
<h3>HW-Eloquent is a minimalistic Lisp dialect to abstract over HWVM programs</h3>
<h4>SYNTAX:</h4>
<ul>
<li>If statement:
<ul>
<li><code>(if bool</code> -&gt; If <code>bool</code> evaluates to an unsigned scalar that is not 0:
<ul>
<li><code>ontrue</code> -&gt; Evaluate this.</li>
<li><code>onfalse)</code> -&gt; Otherwise evaluate this.</li>
</ul></li>
</ul></li>
<li>Begin Statement: <code>(begin expr1 expr2 ... exprN)</code>
<ul>
<li>Evaluates expressions in order. The <code>begin</code> statement itself evaluates to whatever the last expression evaluates to.</li>
</ul></li>
<li>Lambda statement:
<ul>
<li><code>(lambda args body)</code></li>
<li><code>args</code> -&gt; List of local variables provided as arguments, e.g.&#xA0;literally <code>(a b c)</code>, or if a single variable, <code>a</code>, or if no variables, <code>%</code>.</li>
<li><code>body</code> -&gt; Code to evaluate when calling the procedure, can contain any syntax, statements, or variables accessible from the current scope.</li>
<li>Evaluates to an unnamed procedure that takes the number of arguments in the <code>args</code> list, and evaluates <code>body</code>, substituting them inside as appropiate.</li>
<li>The variable called <code>self</code> represents the procedure itself, so it may be called to perform recursive calls, and it will run separately and perform independent variable substitution.</li>
</ul></li>
<li>Procedure call: <code>(procedure arg1 arg2 ...)</code>
<ul>
<li>Call procedure with arguments. The arguments are evaluated in left-to-right order before passing them to the procedure. Evaluates to whatever the procedure body evaluates.</li>
</ul></li>
<li>Define variable: <code>(define var val)</code>
<ul>
<li>Define a local variable in the current scope, <code>var</code> to mean a specific value, <code>val</code>. If it already exists, redefine <code>var</code>.</li>
<li>Evaluates to <code>val</code>.</li>
<li>EXAMPLE: <code>(define myfunc (lambda x (if (eq? x 0) (0) (self (sub x 1)) )))</code>
<ul>
<li>Defines <code>myfunc</code> to mean the calling of <code>myfunc</code> as many times as the value of the unsigned scalar <code>x</code>, and it evaluates deterministically to the unsigned scalar <code>0</code>.</li>
</ul></li>
</ul></li>
</ul>
<h3>CORE PROCEDURES:</h3>
<ul>
<li>PROCEDURE: (CONStruct dotted pair): <code>(cons A B)</code> -&gt; <code>(A . B)</code>
<ul>
<li>Result is known as a cons cell.</li>
</ul></li>
<li>PROCEDURE: <code>(car a)</code>
<ul>
<li>Where <code>a</code> is a cons cell, evaluates to the left element of <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(cdr a)</code>
<ul>
<li>Where <code>a</code> is a cons cell, evaluates to the right element of <code>a</code>.</li>
</ul></li>
<li>PROCEDURE: <code>(nil? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is <code>%</code>. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(atom? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is an atom. Otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(procedure? a)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> is a procedure, otherwise it evaluates to 0.</li>
</ul></li>
<li>PROCEDURE: <code>(eq? a b)</code>
<ul>
<li>Evaluates to 1 if <code>a</code> and <code>b</code> are both atoms, and both are the exact same atom. Otherwise it evaluates to 0.</li>
</ul></li>
</ul>
<h3>OPERATION PROCEDURES:</h3>
<ul>
<li>RULES:
<ul>
<li>The first six apply the operation, and evaluate to a dotted pair of the form <code>(VAL . CF)</code>, where <code>VAL</code>is an unsigned scalar representing the result, and <code>CF</code> is an unsigned scalar that is one if there was overflow/underflow, and zero if there wasn&#x2019;t.</li>
<li><code>halt</code> evaluates to <code>%</code>, as it is only useful for its side effects.</li>
</ul></li>
<li>PROCEDURE: (bitwise add): <code>(add x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise substract): <code>(sub x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise and): <code>(and x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise or): <code>(or x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise xor): <code>(xor x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
</ul></li>
<li>PROCEDURE: (bitwise shift): <code>(shift x y)</code>
<ul>
<li>Where <code>x</code> and <code>y</code> are unsigned scalars.</li>
<li>Behaviour corresponds to HWVM shift instruction.</li>
</ul></li>
<li>PROCEDURE: (address set): <code>(set addrpair y)</code>
<ul>
<li>Where <code>addrpair</code> is a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to set.</li>
<li>Where <code>y</code> is either an unsigned scalar, or a cons cell of the form <code>(high . low)</code>, for the high and low byte of the address to read. Evaluates to the value written to <code>addrpair</code>.</li>
</ul></li>
<li>PROCEDURE 17: <code>(halt)</code>
<ul>
<li>Terminates the program.</li>
</ul></li>
</ul>
<h3>CLARIFICATIONS</h3>
<ul>
<li>A list is either <code>%</code> or a cons cell where the right hand side is a list. Hence, <code>(a . b)</code>, <code>a</code>, <code>(a . (b . c) . %)</code> are not lists, but <code>(a . ((b . %) . %))</code>, <code>(a . %)</code> are lists.</li>
<li><code>(a b c)</code> notation stands for the list <code>(a . (b . (c . %)))</code>. Hence, <code>(procedure a b c)</code> stands for <code>(procedure . (a . (b . (c . %))))</code>. <code>((a b) c)</code> stands for <code>((a . (b . %)) . (c . %))</code>.</li>
<li>In Eloquent, every piece of data is either a cons cell or an atom. The only three possible types for atoms are unsigned scalar, procedure, or <code>%</code>.</li>
<li>An atom may be checked for with the procedure <code>atom?</code>, <code>%</code> with the procedure <code>nil?</code>, procedure type with <code>procedure?</code>, and equality of two atoms with <code>eq?</code>.</li>
<li>In the above text of the specification, whenever <code>where X is Y</code> appears, it is to be interpreted as a statement that <code>X</code> MUST be of type <code>Y</code>, and if it is not, an ERROR occurs.</li>
<li>Variables, declared using <code>define</code> or as <code>lambda</code> arguments, are replaced with their associated value. In the case of lambdas, their arguments are replaced with the evaluation of the provided expression in the procedure call. For example, <code>(lambda (myvar) (nand myvar 1))</code> would have <code>myvar</code> in the body replaced with the first argument it is passed, so <code>((lambda (myvar) (nand myvar 1)) 2)</code> would execute code equivalent to <code>(nand 2 1)</code>, which evaluates to the (hexadecimal base) scalar FC.</li>
<li>Variable names may contain any of <code>abcdefghijklmnopqrstuvwxyz?</code></li>
<li>Unsigned scalars may contain any of <code>0123456789ABCDEF</code></li>
<li>Unsigned scalars have a width of 8 bits, hence any unsigned scalar <code>X</code> is effectively processed like so: <code>modulo X 256</code>, before being entered, manipulated, or returned.</li>
<li>To <code>set</code> addresses lower than <code>(01 . 00)</code> is an ERROR. These lower addresses are reserved for special purposes.</li>
<li>To <code>set</code> an address to itself is considered only a read, and it is hence allowed even if the address is read-only.</li>
<li>Take into account HWVM allows addresses to be READ-ONLY or UNMAPPED. Writing to the former is an ERROR, doing anything with the latter is an ERROR.</li>
<li>No statement in this specification applies as soon as an ERROR has occurred. The program may continue functioning after handling the ERROR gracefully, it may stop functioning, or it may continue functioning in a noncompliant state.</li>
<li>Any <code>lambda</code> bodies, or any statement or syntax (Usually enclosed in parentheses) present inside another (usually) parentheses-enclosed statement, may reference both local variables, and variables from a higher scope. More formally, variables are lexically scoped. For instance, <code>(define curryadd (lambda x (lambda y (add x y))))</code> defines a procedure <code>curryadd</code> that returns another procedure <code>(lambda y (add x y))</code> incorporating a higher-scope variable. <code>(curryadd 2)</code> returns a procedure that adds <code>2</code> and <code>y</code> when called with a single argument.</li>
<li>Because of the aforementioned lexical scoping, variables defined with <code>define</code> or as arguments to a procedure with <code>lambda</code> automatically stop being available as soon as the procedure or statement scope is left. These local variables always take priority over identically-named higher-scope variables, to avoid name clashing.</li>
<li>The highest scope or &#x2018;global&#x2019; scope is that in which all statements start. A series of statements in the global scope will automatically be wrapped in a <code>begin</code> statement, so they are executed sequentially. This ensures a program such as <code>(define x FF) (car (add x 4))</code> has a single return value of <code>3</code>, and it is equivalent to <code>(begin (define x FF) (car (add x 4)))</code>.</li>
</ul>
